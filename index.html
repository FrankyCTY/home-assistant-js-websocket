<!doctype html>
<html>
  <!-- To try locally, run: `yarn build` and then `npx http-server -o` -->

  <body>
    <button onclick="connection.reconnect()">Reconnect</button>
    <button onclick="setupEntitiesSubscription()">Re-subscribe</button>
    <table>
      <tbody></tbody>
    </table>
    <script type="module">
      import {
        getAuth,
        getUser,
        callService,
        createConnection,
        subscribeEntities,
        ERR_HASS_HOST_REQUIRED,
      } from "./dist/index.js";

      (async () => {
        let auth;
        const storeAuth = true;
        const authOptions = storeAuth
          ? {
              async loadTokens() {
                try {
                  return JSON.parse(localStorage.hassTokens);
                } catch (err) {
                  return undefined;
                }
              },
              saveTokens: (tokens) => {
                localStorage.hassTokens = JSON.stringify(tokens);
              },
            }
          : {};
        try {
          auth = await getAuth(authOptions);
        } catch (err) {
          // TODO: No auth data (e.g. tokens) received, and no hassUrl was passed in. Something is wrong, client should pass in a hassUrl to start the getAuth().
          if (err === ERR_HASS_HOST_REQUIRED) {
            // TODO: Ask user to provide the hassUrl to getAuth().
            authOptions.hassUrl = prompt(
              "What host to connect to?",
              "http://localhost:8123",
            );
            if (!authOptions.hassUrl) return;
            auth = await getAuth(authOptions);
          } else {
            alert(`Unknown error: ${err}`);
            return;
          }
        }
        // TODO: =========== At this point the auth instance is created and we have tokens, and might be saved in local storage if the option saveTokens is set. ============
        // TODO: Create the connection object for subsequent normal operations.
        const connection = await createConnection({ auth });

        // TODO: Set up event listeners for the connection object.
        for (const ev of ["disconnected", "ready", "reconnect-error"]) {
          connection.addEventListener(ev, () => console.log(`Event: ${ev}`));
        }

        // Clear url if we have been able to establish a connection
        if (location.search.includes("auth_callback=1")) {
          // TODO: Remove the query string (e.g., ?auth_callback=1) from the URL in the browser address bar, without reloading the page.
          history.replaceState(null, "", location.pathname);
        }

        // TODO: Attach auth & connection obj to window to allow easier debugging on browser console.
        window.auth = auth;
        window.connection = connection;
        // TODO: Try "command" to get user info. (see commands.ts)
        getUser(connection).then((user) => {
          console.log("Logged in as", user);
          window.user = user;
        });

        setupEntitiesSubscription();
      })();

      let unsubEntities;

      window.setupEntitiesSubscription = async () => {
        if (unsubEntities) {
          unsubEntities();
          console.log("Sleeping");
          await new Promise((resolve) => setTimeout(resolve, 4000));
        }
        // TODO: Subscribe to the entities collection state changes.
        unsubEntities = subscribeEntities(connection, (entities) =>
          renderEntities(connection, entities),
        );
      };

      // TODO: Render the entities to the browser DOM on state changes.
      function renderEntities(connection, entities) {
        window.entities = entities;
        const root = document.querySelector("tbody");
        while (root.lastChild) root.removeChild(root.lastChild);

        Object.keys(entities)
          .sort()
          .forEach((entId) => {
            const tr = document.createElement("tr");

            const tdName = document.createElement("td");
            tdName.innerHTML = entId;
            tr.appendChild(tdName);

            const tdState = document.createElement("td");
            const text = document.createTextNode(entities[entId].state);
            tdState.appendChild(text);

            if (
              ["switch", "light", "input_boolean"].includes(
                entId.split(".", 1)[0],
              )
            ) {
              const button = document.createElement("button");
              button.innerHTML = "toggle";
              button.onclick = () =>
                callService(connection, "homeassistant", "toggle", {
                  entity_id: entId,
                });
              tdState.appendChild(button);
            }
            tr.appendChild(tdState);

            root.appendChild(tr);
          });
      }
    </script>
  </body>
</html>
